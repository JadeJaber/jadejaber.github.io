---
published: true
layout: post
excerpt: null
categories: articles
share: true
tags:
  - linux
  - security
  - certificates
  - architecture theory
---
We are going to discuss in this article about the following concepts. The article is divided in 2 parts: a glossary and  the "why and how" of the certificates/public/private keys.

The certificates are mainly used for 3 uses cases : 
- **Authentication**: The assurance to one entity that another entity is who he/she/it claims to be.
- **Integrity**: The assurance to an entity that data has not been altered (intentionally or unintentionally) between "there" and "here," or between "then" and "now."
- **Confidentiality**: The assurance to an entity that no one can read a particular piece of data except the receiver(s) explicitly intende

> Any comments are welcomed, I'm not an expert, I'm just trying to sum up the why and how of those elements.

## Glossary
### PKI
A typical PKI consists of hardware, software, policies and standards to **manage the creation, administration, distribution and revocation of keys and digital certificates**. 

A typical PKI includes the following key elements:

- A **trusted party**, called a certificate authority (CA), acts as the root of trust and provides services that authenticate the identity of individuals, computers and other entities
- A **registration authority**, often called a subordinate CA, certified by a root CA to issue certificates for specific uses permitted by the root
- A **certificate database**, which stores certificate requests and issues and revokes certificates
- A **certificate store**, which resides on a local computer as a place to store issued certificates and private keys

![pki]({{site.baseurl}}/images/pki.jpg)

### Private & Public keys & asymmetric cryptography
Private and public keys are randomly generated string of characters. They are used to encrypt and decrypt messages. The private key is never revealed to anyone whereas the public key may publicly revealed. 

A message encrypted with a private key may only be decrypted with the associated public key and vice versa. This is what we call **asymmetric cryptography**. As oppposed to **symmetric cryptography** which needs only a unique key to encrypt and decrypt messages.

Note that only the messages which are encrypted with the public key are "secret" since the ones that are encrypted with the private key may decrypted by anyone who owns the public key which is publicly available.

### Certificate 
A certificate is an envelope which contains (among other elements), the public key of the secured server and a "signature". The signature is generated by hashing the whole certificate with all its messages using a hash algorithm (ex : SHA1 or MD5) ans the result of that hash is called  a digest. The digest is then encrypted with a private key (usually it is a Certificate Authorithy's private key). The encrypted digest is what we call the "signature". Thus, a **certificate** embeds the **public key** and **some identification meta data** concerning the server and the **signature**.

<figure class="half">
	<img src="/images/Certificate_2.gif" alt="Certificate">
	<img src="/images/Certificate_1.gif" alt="Certificate">
	<figcaption>Certificate content</figcaption>
</figure>

### Signature
A signature is a message (usually a digest generated with a hashing algorithm) which has been encrypted using a private or a public key.

### Keystore & Trustore
Keystore & Trustsore are are mainly the same type of element. They are safes which contain private keys, public keys and certificates and which are protected with a password. The keystore contains your public/private keys and certificates whereas the Truststore contains the certificates of the authorities or servers that you trust.

### Asymmetric vs symmetric cryptography
A crypted communication may be done either with a unique key -> symmetric (DES & AES) or with 2 key, private & public -> asymmetric (RSA et DSA)  

**Pros and cons** : The problem with symmetric cryptography is that a secured server who wants to receive encrypted messages (secured web server for instance) will have to generated a different encryption key for each server that need to communicate with it. If all other servers had the same encryption key, then they would all be able to decrypt each othes messages that they each send to the secured server. **-> This is why we need asymmetric cryptography**.

## Why and how  (########### reprendre ici)
### Encrypted communication (SSL)

Since the symmetric cryptography needs less CPU calculation then asymmetric cryptography, it is better to have a symmetric cryptography.  The 2 servers which need to communicate securely need to have the same encryption key. The client will generate a symmetric encryption key, encrpyt it with the public key of the secured server and send it to the secured server. 

Now the 2 servers have the same encryption key and will be able to start an symmetric encrypted communication. Ths encryption key will be used only for that session.

In order to have an asymmetric cryptography the secured server need to send its public key to the client. Here comes the man in the middle vulnerability : If the man in the middle catched the public key of the secured server and sends its own public key to the client, the client would then encrypt its messages with the man in the middle's publick key. The man in the middle would then be able to decrypt the message with its own private key. And then encrypt it again with the secured server public key before sending that message back to the secured server. 

![Man in the middle]({{site.baseurl}}/images/man-in-the-middle.jpg)

We need a solution to garantee to the client (server 3 in the image) that the public key he received is really the one that has been sent by the secured server **-> This is where certificates gets into the act !**

**Once the client server receives that certificate, it does 2 things** :
1. It checks if the public key needed to decrypt the signature is in its trustore. In that case, **it means it can trust the incoming message**. The client decrypts the signature and gets ths digest. 
2. The client then generates the digest with the same algorithm used by the secured server and it compares both digests. It they match, the client has the guarantee that the public key embeded in the certificate **has not been altered** and thus can be used to encrypt sensitive data. 

If the man in the middle tried to get into this communication, its certificate would have been rejected from the client since the client does not have the public key of the signatory of the man in the middle's certificate (whether it is self-signed or signed by CA certificate) 
 
### Message integrity
L’intégrité des données est assurée par la signature : 
Un digest est calculé à partir du message envoyé
Le digest est crypté avec la clé privée de l’envoyeur
Le digest est embarqué avec le message envoyé
Le client décrypte le digest avec la clé publique de l’envoyeur et recalcule le digest à partir du message
Et si les digests correspondent c’est que le message est intègre et on est sûr de l’identité de l’envoyeur.
Dans ce cas précis, le message n’est pas crypté mais son intégrité est assurée.

![Signature]({{site.baseurl}}/images/Signature.gif)

![former-us-vice-president-dick-cheney.jpg]({{site.baseurl}}/images/former-us-vice-president-dick-cheney.jpg)

![dream_561d4e54f78.jpg]({{site.baseurl}}/images/dream_561d4e54f78.jpg)

![dream_561d4e54f7.jpg]({{site.baseurl}}/images/dream_561d4e54f7.jpg)

 
 ## Tools 
- Open-ssl
- keytool
[Link to Cheat sheets]({{site.baseurl}}/articles/2017-02-28-keytool-openssl-cheat-sheet)
