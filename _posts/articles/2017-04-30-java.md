---
published: true
layout: post
excerpt: description
categories: articles
share: true
tags:
  - ENVIRONNEMENT EDITEUR
  - linux
  - hortonworks
  - hadoop
  - NoSQL
  - LIBRARY
  - spark streaming
  - spark SQL
  - spark ML/MlLib
  - panda
  - scikit learn
  - pySpark
  - kafka streaming
  - kafka connect
  - shell
  - LANGAGE
  - java
  - python
  - spark
  - scala
  - hive
  - pig
  - ROLE
  - execution engine
  - data visualization
  - storage
  - machine learning
  - data processing
  - database
  - streaming
  - compression
  - proxy
  - data ingestion
  - search engine
  - resource manager
  - cluster manager
  - SUBJECT
  - benchmark
  - tips
  - cheat sheet
  - debug troubleshooting
  - optimization
  - security
  - network
  - certificates
  - architecture theory
  - api
  - MACHINE LEARNING
  - logistic regression
  - linear regression
  - deep learning
  - neuronal networks
  - statistics
  - SOLUTION
---
## 1 Java Modifiers
### 1.1 Access Modifiers − default, public , protected, private
Java provides a number of access modifiers to set access levels for classes, variables, methods, and constructors. The four access levels are −
  - Visible to the package, the default. No modifiers are needed.
  - Visible to the class only (**private**).
  - Visible to the world (**public**).
  - Visible to the package and all subclasses (**protected**).
>The fields in an interface are implicitly public static final and the methods in an interface are by default public.

**Access Control and Inheritance**
The following rules for inherited methods are enforced
- Methods declared public in a superclass also must be public in all subclasses.
- Methods declared protected in a superclass must either be protected or public in subclasses; they cannot be private.
- Methods declared private are not inherited at all, so there is no rule for them.


### 1.2 Non-access Modifiers − final, abstract, strictfp
[https://www.tutorialspoint.com/java/java_nonaccess_modifiers.htm(https://www.tutorialspoint.com/java/java_nonaccess_modifiers.htm)

#### 1.2.1 Static
 - Static **variable** : The static keyword is used to create variables that will exist independently of any instances created for the class. Only one copy of the static variable exists regardless of the number of instances of the class
 - Static **Method** : The static keyword is used to create methods that will exist independently of any instances created for the class.

#### 1.2.2 Final
 - A final **variable** can be explicitly initialized only once. 
 - A final **method** cannot be overridden by any subclasses.
 - The main purpose of using a class being declared as final is to prevent the **class** from being subclassed
 

#### 1.2.3 Abtract
An abstract class can never be instantiated. If a class is declared as abstract then the sole purpose is for the class to be extended.
An abstract method is a method declared without any implementation. The methods body (implementation) is provided by the subclass. Abstract methods can never be final or strict.
>Any class that extends an abstract class must implement all the abstract methods of the super class, unless the subclass is also an abstract class.

#### 1.2.4 The Synchronized Modifier
The synchronized keyword used to indicate that a method can be accessed by only one thread at a time. The synchronized modifier can be applied with any of the four access level modifiers.

#### 1.2.5 The Transient Modifier
An instance variable is marked transient to indicate the JVM to skip the particular variable when serializing the object containing it

#### 1.2.6 The Volatile Modifier
The volatile modifier is used to let the JVM know that a thread accessing the variable must always merge its own private copy of the variable with the master copy in the memory.

Accessing a volatile variable synchronizes all the cached copied of the variables in the main memory. Volatile can only be applied to instance variables, which are of type object or private. A volatile object reference can be null.

```java
public class MyRunnable implements Runnable {
   private volatile boolean active;

   public void run() {
      active = true;
      while (active) {   // line 1
         // some code here
      }
   }

   public void stop() {
      active = false;   // line 2
   }
}
``` 
>Usually, run() is called in one thread (the one you start using the Runnable), and stop() is called from another thread. If in line 1, the cached value of active is used, the loop may not stop when you set active to false in line 2. That's when you want to use volatile.

## 2. Java Variables
[https://www.tutorialspoint.com/java/java_variable_types.htm](https://www.tutorialspoint.com/java/java_variable_types.htm)	
Following are the types of variables in Java −
- **Local** variables − Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.
- **Instance** variables − Instance variables are variables within a class but outside any method. These variables are initialized when the class is instantiated. Instance variables can be accessed from inside any method, constructor or blocks of that particular class. The instance variables are visible for all methods, constructors and block in the class. Normally, it is recommended to make these variables private (access level). However, visibility for subclasses can be given for these variables with the use of access modifiers.
- **Class** variables − Class variables are variables declared within a class, outside any method, with the static keyword.


## 3. Data Types

**Java Arrays**
Arrays are objects that store multiple variables of the same type. However, an array itself is an object on the heap. We will look into how to declare, construct, and initialize in the upcoming chapters.

**Java Enums**
Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.

**Interfaces**
In Java language, an interface can be defined as a contract between objects on how to communicate with each other. Interfaces play a vital role when it comes to the concept of inheritance.

An interface defines the methods, a deriving class (subclass) should use. But the implementation of the methods is totally up to the subclass.



##########  J'en suis la https://www.tutorialspoint.com/java/java_arrays.htm